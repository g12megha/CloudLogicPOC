'use strict';

var fs = require('fs');
var path = require('path');
var safeRegex = require('safe-regex');
var VError = require('verror').VError;
var loggingUtils = require('../utils/logger');
var logger = loggingUtils.getLogger('/Configuration');
var tracer = loggingUtils.getTracer();
var fsUtils = require('../utils/fs-utils');
var validators = require('./validators');
var prettyPrint = require('../utils/pretty-print.js');
var uaaUtils = require('../utils/uaa-utils');
var environment = require('../environment');
var _ = require('lodash');


exports.loadConfiguration = function(directory, fileName, envDestinations) {
  var fullFileName = path.join(directory, fileName);
  var configuration;
  var isFile = fsUtils.isFile(fullFileName);

  if (isFile) {
    try {
      tracer.info('Loading configuration from ', fullFileName);
      configuration = JSON.parse(fs.readFileSync(fullFileName, 'utf8'));
    } catch (e) {
      throw new VError(e, 'Invalid content in %s', fullFileName);
    }
  } else {
    tracer.info('The file %s does not exist', fullFileName);
  }

  if (configuration) {
    if (configuration.sessionTimeout) {
      logger.warning('DEPRECATED: sessionTimeout in xs-app.json is a subject to deprecation in the next major version! Please use environment variable SESSION_TIMEOUT.');
    }
    validators.validateXsApp(configuration, envDestinations, directory);
    if (configuration.authenticationMethod === 'none') {
      logger.warning('No authentication will be used when accessing backends. Scopes defined in routes will be ignored.');
    }

    configuration.routes = configuration.routes || [];
    var hasLocalDirSet = configuration.routes.some(function(currentRoute) {
      return !!currentRoute.localDir;
    });

    if (!hasLocalDirSet) {
      if (fsUtils.isDirectory(path.join(directory, 'resources'))) {
        configuration.routes.push({
          source: '^/(.*)',
          localDir: 'resources'
        });
      } else {
        logger.info('xs-app.json: Application does not have directory for static resources!');
      }
    }

    processRoutes(directory, configuration);

    configuration.mergePluginsIntoRoutes = function(plugins) {
      configuration.routes = (plugins || []).concat(configuration.routes);
      if (tracer.isEnabled('debug')) {
        tracer.debug('After merging plugin configurations into the routes, ' +
          'following routing configuration will be used:\n' +
          JSON.stringify(configuration.routes, prettyPrint.prettyPrintRegExp, 2));
      }

    };

    handleReplace(configuration);
    return configuration;
  }
  logger.info('Using empty configuration to run');

  return {
    'getPublicPaths': function() {
    },
    'mergePluginsIntoRoutes': function() {
    }
  };
};

function handleReplace(configuration) {
  configuration.routes.forEach(function (route) {
    if (route.replace) {
      route.replace.varsMap = route.replace.vars.reduce(function (result, varName) {
        result[varName] = process.env[varName];
        return result;
      }, {});
    }
  });
}

function processRoutes(workingDir, configuration) {
  var localServiceConfigPath = environment.getLocalServiceConfigPath(workingDir);
  var uaaOptions = uaaUtils.getOptions(localServiceConfigPath);
  var appName = uaaOptions.xsappname;

  if (_.isEmpty(uaaOptions)) {
    logger.info('Replacing $XSAPPNAME will not take place - UAA configuration not provided.');
  } else if (!appName) {
    logger.info("Replacing $XSAPPNAME will not take place - 'xsappname' property not found in UAA configuration.");
  }

  configuration.routes.forEach(function (currentRoute) {
    currentRoute.source = new RegExp(currentRoute.source);
    if (!safeRegex(currentRoute.source)) {
      logger.warning('Route with source ', currentRoute.source, ' is vulnerable to ReDoS attacks');
    }
    if (currentRoute.authenticationType === 'none' && currentRoute.scope) {
      logger.warning('Route with source ', currentRoute.source, ' does not require authentication. Defined scopes will be ignored.');
    }
    currentRoute.scope = processScope(currentRoute.scope, appName);
  });
  if (tracer.isEnabled('debug')) {
    tracer.debug('Routes after being processed', JSON.stringify(configuration.routes, prettyPrint.prettyPrintRegExp, 2));
  }
}

function processScope(scope, appName) {
  if (!scope) {
    return;
  }
  if (typeof scope === 'string') {
    scope = [scope];
  }
  if (Array.isArray(scope)) {
    if (appName) {
      return replaceApplicationName(scope, appName);
    }
  } else {
    for (var httpMethod in scope) {
      var scopesPerMethod = scope[httpMethod];
      if (typeof scopesPerMethod === 'string') {
        scopesPerMethod = [scopesPerMethod];
      }
      scope[httpMethod] = appName ? replaceApplicationName(scopesPerMethod, appName) : scopesPerMethod;
    }
  }
  return scope;
}

function replaceApplicationName(scopes, appName) {
  return scopes.map(function (scopeName) {
    return scopeName.replace(/^\$XSAPPNAME/, appName);
  });
}
