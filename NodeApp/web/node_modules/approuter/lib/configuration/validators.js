'use strict';

var _ = require('lodash');
var URI = require('urijs');
var path = require('path');
var VError = require('verror').VError;
var jsonValidator = require('tv4');
var fsUtils = require('../utils/fs-utils');
var xsAppSchema = require('./schemas/xs-app-schema');
var scopesSchema = require('./schemas/scopes-schema');
var pluginsSchema = require('./schemas/plugins-schema');
var headersSchema = require('./schemas/headers-schema');
var envDestinationsSchema = require('./schemas/destinations-schema');
var environmentSchema = require('./schemas/environment-schema');
var whitelistSchema = require('./schemas/whitelist-schema');

module.exports = {
  validateXsApp: function(configuration, envDestinations, directory) {
    addConfigurationDefaults(configuration);

    jsonValidator.addSchema('scopesSchema', scopesSchema);
    jsonValidator.addFormat('relative-uri', validateRelativeUri);
    jsonValidator.addFormat('uri', validateUri);
    jsonValidator.addFormat('regex', validateRegex);

    jsonValidator.addFormat('route-rules', function(route) {
      if (!route.target && !route.destination && !route.localDir) {
        return 'Route does not have a target, destination nor a localDir';
      }

      if (route.destination) {
        if (envDestinations && !envDestinations[route.destination]) {
          return 'Route references unknown destination "' + route.destination + '"';
        }
        if (route.localDir) {
          return 'Route has both localDir and destination';
        }
      }

      if (route.localDir) {
        var fullPath = path.join(directory, route.localDir);
        if (!fsUtils.isDirectory(fullPath)) {
          return fullPath + ' is not a directory';
        }
      } else if (route.replace) {
        return 'Route has replace with no localDir';
      }
    });

    jsonValidator.addFormat('logout-rules', function (logout) {
      if (logout.logoutPage && !logout.logoutEndpoint) {
        return 'Logout page is set although logout endpoint is not configured';
      }
    });

    validateSchema(configuration, xsAppSchema, 'xs-app.json');

    var routeDestinations = _.map(configuration.routes || [], 'destination').filter(_.identity);
    var unusedDestinations = _.difference(Object.keys(configuration.destinations || {}), routeDestinations);
    if (unusedDestinations.length > 0) {
      throw new VError('Destination(s) "%s" not used by any route', unusedDestinations);
    }
  },

  validateEnvDestinations: function(configuration) {
    jsonValidator.addFormat('no-duplicate-names', function(destinations) {
      var duplicates = _.chain(destinations).countBy('name').pick(function(count) { return count > 1; }).keys().value();
      if (duplicates.length > 0) {
        return 'Duplicate destination names: ' + duplicates;
      }
    });

    jsonValidator.addFormat('valid-port', function(proxyPort) {
      return validatePort(proxyPort, 'Destination "proxyPort"');
    });

    jsonValidator.addFormat('absolute-uri', validateAbsoluteUri);

    validateSchema(configuration, envDestinationsSchema, 'environment-destinations');
  },

  validateEnvironmentSettings: function(configuration) {
    validateSchema(configuration, environmentSchema, 'environment-settings');
  },

  validatePlugins: function(configuration, envDestinations) {
    jsonValidator.addSchema('scopesSchema', scopesSchema);
    jsonValidator.addFormat('regex', validateRegex);
    jsonValidator.addFormat('relative-uri', validateRelativeUri);

    jsonValidator.addFormat('plugin-rules', function(plugin) {
      if (envDestinations && plugin.destination && !envDestinations[plugin.destination]) {
        return 'Plugin references destination "' + plugin.destination + '", which cannot be found in the environment';
      }
    });

    validateSchema(configuration, pluginsSchema, 'plugins');
  },

  validateHeaders: function(configuration) {
    jsonValidator.addFormat('headers-rules', function(header) {
      var key = Object.keys(header)[0];
      var headerNamePattern = /^[!#$%&'*+\-.^_`|~0-9a-zA-Z]+$/; // http://tools.ietf.org/html/rfc7230#section-3.2.6
      if (!headerNamePattern.test(key)) {
        return 'Header does not have a valid name';
      }
      if (/\r?\n/.test(header[key])) {
        return 'Header value contains line breaks';
      }

      var headerName = key.match(headerNamePattern)[0];
      if (headerName.toLowerCase() === 'set-cookie' || headerName.toLowerCase() === 'cookie') {
        return 'Headers "set-cookie" and "cookie" are not allowed in the additional headers';
      }
    });

    validateSchema(configuration, headersSchema, 'http-headers');
  },

  validateWhitelist: function(whitelist) {
    jsonValidator.addFormat('hostname-rules', function(listItem) {
      var regexHostName = /^(\*\.)?(([a-zA-Z]|[a-zA-Z][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z]|[A-Za-z][A-Za-z0-9\-]*[A-Za-z0-9])$/;
      var regexIPHostName = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/;

      if (!(regexHostName.test(listItem.host) || regexIPHostName.test(listItem.host))) {
        return 'Whitelist item\'s host "' + listItem.host + '" is not correct. Possible values allow valid hostname, IP or hostname prefixed with *.';
      }
    });

    jsonValidator.addFormat('valid-port', function(proxyPort) {
      return validatePort(proxyPort, 'Whitelist item\'s port');
    });

    validateSchema(whitelist, whitelistSchema, 'clickjack-whitelist');
  }
};

function addConfigurationDefaults(configuration) {
  var defaultSessionTimeoutInMinutes = 15;
  var defaultLoginCallback = '/login/callback';
  var websocketsEnabledByDefault = false;
  var compressionEnabledByDefault = true;

  // Deprecated - when this is deleted, defaultSessionTimeoutInMinutes should be moved in env-config.js where environment is loaded
  configuration.sessionTimeout = configuration.sessionTimeout || defaultSessionTimeoutInMinutes;
  configuration.login = getPropertyValue(configuration, 'login', { callbackEndpoint: defaultLoginCallback });
  configuration.compression = getPropertyValue(configuration, 'compression', { enabled: compressionEnabledByDefault });
  configuration.websockets = getPropertyValue(configuration, 'websockets', { enabled: websocketsEnabledByDefault });
}

function getPropertyValue(configObject, propertyName, defaultValue) {
  if (configObject.hasOwnProperty(propertyName)) {
    return configObject[propertyName];
  }
  return defaultValue;
}

function validateRelativeUri(relativeUri) {
  var components = URI.parse(relativeUri);
  if (components.protocol || components.hostname) {
    return 'URI must be a relative path';
  }
}

function validateAbsoluteUri(uri) {
  var components = URI.parse(uri);
  if (!components.protocol || !components.hostname) {
    return 'URI must be absolute';
  }
  var supportedProtocols = ['http', 'https', 'ws', 'wss'];
  if (!_.contains(supportedProtocols, components.protocol)) {
    return 'URI has unsupported protocol, supported protocols are ' + supportedProtocols;
  }
}

function validateUri(uri) {
  var components = URI.parse(uri);
  if (components.protocol && components.protocol !== 'http' && components.protocol !== 'https') {
    return "Supported schemes are 'http' and 'https'";
  }
}

function validateRegex(regex) {
  try {
    regex = new RegExp(regex);
  } catch (exception) {
    return exception;
  }
}

function validatePort(port, messagePrefix) {
  var portMinValue = 1;
  var portMaxValue = 65535;
  if (typeof port === 'string' && !/^[1-9]\d*$/.test(port)) {
    return messagePrefix + ' value is string, which cannot be parsed as positive integer';
  }
  port = parseFloat(port);
  if (port < portMinValue || port > portMaxValue) {
    return messagePrefix + ' value has to be string or integer between ' + portMinValue + '-' + portMaxValue;
  }
}

function validateSchema(configuration, schema, source) {
  if (!jsonValidator.validate(configuration, schema)) {
    throw new VError('%s%s: %s', source, jsonValidator.error.dataPath, jsonValidator.error.message);
  }
  jsonValidator = jsonValidator.freshApi();
}
