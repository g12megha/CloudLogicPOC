'use strict';

var tokens = require('csrf')({ 'secretLength': 32 });
var pathUtil = require('../utils/path-util.js');
var sessionExt = require('../utils/session-ext');

module.exports = {
  /**
   * Checks if a token is required for an incoming request:
   *  - GET request do not require a token (except a GET request is used to fetch a new token)
   *  - public path requests do not require a token
   *
   * @param req
   * @returns true if a token is required, else false
   */
  isTokenRequired: function(req) {
    if (req.internalUrl && req.internalUrl.route.csrfProtection === false) {
      return false;
    }

    if (isGetRequest(req)) {
      // GET request do require a token only if header 'x-csrf-token: fetch' is sent
      return hasTokenFetchHeader(req);
    }

    if (isHeadRequest(req) || isPublicPathRequest(req)) {
      // request to public paths not require a token even if they use POST, PUT, ...
      return false;
    }

    // POST, PUT, DELETE, ... request to private path
    return true;
  },

  /**
   * Checks if the incoming request is a token fetch request:
   *
   * @param req
   * @returns true if incoming request is a token fetch request, else false
   */
  isTokenFetchRequest: function(req) {
    if (isGetRequest(req) && hasTokenFetchHeader(req)) {
      // GET request with x-csrf-token: fetch do resolve with new token
      return true;
    }
    return false;
  },

  /**
   * Check a token send by the client
   *
   * @param req
   * @returns {isValid: boolean, details: string}
   */
  checkToken: function(req) {
    var tokenHeader = req.headers['x-csrf-token'];
    if (!tokenHeader) {
      return { isValid: false, details: 'The request does not contain a x-csrf-token' };
    } else {
      if (req.session && req.session.xsrf && req.session.xsrf.token === tokenHeader) {
        return { isValid: true, details: 'The request contains a valid x-csrf-token' };
      } else {
        return { isValid: false, details: 'The request contains an invalid x-csrf-token' };
      }
    }
  },

  /**
   * Returns a new token and 'stores a new'/'reuses an existing' token secret in the session
   *
   * @param req
   * @param cb function cb(err, token)
   */
  getNewToken: function (req, cb) {
    if (!req.session) {
      return cb(new Error('No session established. Failed to store token in session'));
    }

    if (req.session && req.session.xsrf && req.session.xsrf.secret) {
      return setTokenToSession(req.session, req.session.xsrf.secret, cb);
    }

    tokens.secret(function (err, secret) {
      if (err) {
        return cb(err);
      }
      setTokenToSession(req.session, secret, cb);
    });
  }
};

function setTokenToSession(session, secret, cb) {
  var token;
  sessionExt.update(session, function(session) {
    token = tokens.create(secret);
    session.xsrf = {
      token: token,
      secret: secret
    };
  });

  cb(null, token);
}

function isGetRequest(req) {
  return req.method === 'GET';
}

function isHeadRequest(req) {
  return req.method === 'HEAD';
}

function isPublicPathRequest(req) {
  return pathUtil.isPublicPath(req, req.app.get('routerConfig').appConfig);
}

function hasTokenFetchHeader(req) {
  var tokenHeader = req.headers['x-csrf-token'];
  return ((tokenHeader) ? tokenHeader.toLowerCase() === 'fetch' : false);
}
